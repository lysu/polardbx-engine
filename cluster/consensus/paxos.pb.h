// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paxos.proto

#ifndef PROTOBUF_INCLUDED_paxos_2eproto
#define PROTOBUF_INCLUDED_paxos_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_paxos_2eproto 

namespace protobuf_paxos_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_paxos_2eproto
namespace alisql {
class ClusterInfoEntry;
class ClusterInfoEntryDefaultTypeInternal;
extern ClusterInfoEntryDefaultTypeInternal _ClusterInfoEntry_default_instance_;
class CompressedLogEntries;
class CompressedLogEntriesDefaultTypeInternal;
extern CompressedLogEntriesDefaultTypeInternal _CompressedLogEntries_default_instance_;
class ConfigureChangeValue;
class ConfigureChangeValueDefaultTypeInternal;
extern ConfigureChangeValueDefaultTypeInternal _ConfigureChangeValue_default_instance_;
class LogEntry;
class LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class PaxosMsg;
class PaxosMsgDefaultTypeInternal;
extern PaxosMsgDefaultTypeInternal _PaxosMsg_default_instance_;
class PolarFields;
class PolarFieldsDefaultTypeInternal;
extern PolarFieldsDefaultTypeInternal _PolarFields_default_instance_;
class RDSFields;
class RDSFieldsDefaultTypeInternal;
extern RDSFieldsDefaultTypeInternal _RDSFields_default_instance_;
class TestMsg1;
class TestMsg1DefaultTypeInternal;
extern TestMsg1DefaultTypeInternal _TestMsg1_default_instance_;
class TestMsg2;
class TestMsg2DefaultTypeInternal;
extern TestMsg2DefaultTypeInternal _TestMsg2_default_instance_;
}  // namespace alisql
namespace google {
namespace protobuf {
template<> ::alisql::ClusterInfoEntry* Arena::CreateMaybeMessage<::alisql::ClusterInfoEntry>(Arena*);
template<> ::alisql::CompressedLogEntries* Arena::CreateMaybeMessage<::alisql::CompressedLogEntries>(Arena*);
template<> ::alisql::ConfigureChangeValue* Arena::CreateMaybeMessage<::alisql::ConfigureChangeValue>(Arena*);
template<> ::alisql::LogEntry* Arena::CreateMaybeMessage<::alisql::LogEntry>(Arena*);
template<> ::alisql::PaxosMsg* Arena::CreateMaybeMessage<::alisql::PaxosMsg>(Arena*);
template<> ::alisql::PolarFields* Arena::CreateMaybeMessage<::alisql::PolarFields>(Arena*);
template<> ::alisql::RDSFields* Arena::CreateMaybeMessage<::alisql::RDSFields>(Arena*);
template<> ::alisql::TestMsg1* Arena::CreateMaybeMessage<::alisql::TestMsg1>(Arena*);
template<> ::alisql::TestMsg2* Arena::CreateMaybeMessage<::alisql::TestMsg2>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace alisql {

enum PaxosMsg_MsgErrorType {
  PaxosMsg_MsgErrorType_NONE = 0,
  PaxosMsg_MsgErrorType_APPEND = 1
};
bool PaxosMsg_MsgErrorType_IsValid(int value);
const PaxosMsg_MsgErrorType PaxosMsg_MsgErrorType_MsgErrorType_MIN = PaxosMsg_MsgErrorType_NONE;
const PaxosMsg_MsgErrorType PaxosMsg_MsgErrorType_MsgErrorType_MAX = PaxosMsg_MsgErrorType_APPEND;
const int PaxosMsg_MsgErrorType_MsgErrorType_ARRAYSIZE = PaxosMsg_MsgErrorType_MsgErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PaxosMsg_MsgErrorType_descriptor();
inline const ::std::string& PaxosMsg_MsgErrorType_Name(PaxosMsg_MsgErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PaxosMsg_MsgErrorType_descriptor(), value);
}
inline bool PaxosMsg_MsgErrorType_Parse(
    const ::std::string& name, PaxosMsg_MsgErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PaxosMsg_MsgErrorType>(
    PaxosMsg_MsgErrorType_descriptor(), name, value);
}
// ===================================================================

class LogEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.LogEntry) */ {
 public:
  LogEntry();
  virtual ~LogEntry();

  LogEntry(const LogEntry& from);

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LogEntry* other);
  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogEntry* New() const final {
    return CreateMaybeMessage<LogEntry>(NULL);
  }

  LogEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ikey = 4;
  bool has_ikey() const;
  void clear_ikey();
  static const int kIkeyFieldNumber = 4;
  const ::std::string& ikey() const;
  void set_ikey(const ::std::string& value);
  #if LANG_CXX11
  void set_ikey(::std::string&& value);
  #endif
  void set_ikey(const char* value);
  void set_ikey(const void* value, size_t size);
  ::std::string* mutable_ikey();
  ::std::string* release_ikey();
  void set_allocated_ikey(::std::string* ikey);

  // optional bytes value = 5;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 5;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes opaque = 9;
  bool has_opaque() const;
  void clear_opaque();
  static const int kOpaqueFieldNumber = 9;
  const ::std::string& opaque() const;
  void set_opaque(const ::std::string& value);
  #if LANG_CXX11
  void set_opaque(::std::string&& value);
  #endif
  void set_opaque(const char* value);
  void set_opaque(const void* value, size_t size);
  ::std::string* mutable_opaque();
  ::std::string* release_opaque();
  void set_allocated_opaque(::std::string* opaque);

  // required uint64 term = 1;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // required uint64 index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint64 index() const;
  void set_index(::google::protobuf::uint64 value);

  // required uint64 opType = 3;
  bool has_optype() const;
  void clear_optype();
  static const int kOpTypeFieldNumber = 3;
  ::google::protobuf::uint64 optype() const;
  void set_optype(::google::protobuf::uint64 value);

  // optional uint64 info = 6;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 6;
  ::google::protobuf::uint64 info() const;
  void set_info(::google::protobuf::uint64 value);

  // optional uint64 checksum = 7;
  bool has_checksum() const;
  void clear_checksum();
  static const int kChecksumFieldNumber = 7;
  ::google::protobuf::uint64 checksum() const;
  void set_checksum(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:alisql.LogEntry)
 private:
  void set_has_term();
  void clear_has_term();
  void set_has_index();
  void clear_has_index();
  void set_has_optype();
  void clear_has_optype();
  void set_has_ikey();
  void clear_has_ikey();
  void set_has_value();
  void clear_has_value();
  void set_has_info();
  void clear_has_info();
  void set_has_checksum();
  void clear_has_checksum();
  void set_has_opaque();
  void clear_has_opaque();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ikey_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr opaque_;
  ::google::protobuf::uint64 term_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::uint64 optype_;
  ::google::protobuf::uint64 info_;
  ::google::protobuf::uint64 checksum_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RDSFields : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.RDSFields) */ {
 public:
  RDSFields();
  virtual ~RDSFields();

  RDSFields(const RDSFields& from);

  inline RDSFields& operator=(const RDSFields& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RDSFields(RDSFields&& from) noexcept
    : RDSFields() {
    *this = ::std::move(from);
  }

  inline RDSFields& operator=(RDSFields&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RDSFields& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RDSFields* internal_default_instance() {
    return reinterpret_cast<const RDSFields*>(
               &_RDSFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RDSFields* other);
  friend void swap(RDSFields& a, RDSFields& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RDSFields* New() const final {
    return CreateMaybeMessage<RDSFields>(NULL);
  }

  RDSFields* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RDSFields>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RDSFields& from);
  void MergeFrom(const RDSFields& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RDSFields* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rdsServerId = 1;
  bool has_rdsserverid() const;
  void clear_rdsserverid();
  static const int kRdsServerIdFieldNumber = 1;
  ::google::protobuf::uint32 rdsserverid() const;
  void set_rdsserverid(::google::protobuf::uint32 value);

  // optional uint32 source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  ::google::protobuf::uint32 source() const;
  void set_source(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:alisql.RDSFields)
 private:
  void set_has_rdsserverid();
  void clear_has_rdsserverid();
  void set_has_source();
  void clear_has_source();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 rdsserverid_;
  ::google::protobuf::uint32 source_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PolarFields : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.PolarFields) */ {
 public:
  PolarFields();
  virtual ~PolarFields();

  PolarFields(const PolarFields& from);

  inline PolarFields& operator=(const PolarFields& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PolarFields(PolarFields&& from) noexcept
    : PolarFields() {
    *this = ::std::move(from);
  }

  inline PolarFields& operator=(PolarFields&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PolarFields& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PolarFields* internal_default_instance() {
    return reinterpret_cast<const PolarFields*>(
               &_PolarFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PolarFields* other);
  friend void swap(PolarFields& a, PolarFields& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PolarFields* New() const final {
    return CreateMaybeMessage<PolarFields>(NULL);
  }

  PolarFields* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PolarFields>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PolarFields& from);
  void MergeFrom(const PolarFields& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolarFields* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes extra_value = 3;
  bool has_extra_value() const;
  void clear_extra_value();
  static const int kExtraValueFieldNumber = 3;
  const ::std::string& extra_value() const;
  void set_extra_value(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_value(::std::string&& value);
  #endif
  void set_extra_value(const char* value);
  void set_extra_value(const void* value, size_t size);
  ::std::string* mutable_extra_value();
  ::std::string* release_extra_value();
  void set_allocated_extra_value(::std::string* extra_value);

  // required uint64 start_lsn = 2;
  bool has_start_lsn() const;
  void clear_start_lsn();
  static const int kStartLsnFieldNumber = 2;
  ::google::protobuf::uint64 start_lsn() const;
  void set_start_lsn(::google::protobuf::uint64 value);

  // required uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:alisql.PolarFields)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_start_lsn();
  void clear_has_start_lsn();
  void set_has_extra_value();
  void clear_has_extra_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr extra_value_;
  ::google::protobuf::uint64 start_lsn_;
  ::google::protobuf::uint32 version_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CompressedLogEntries : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.CompressedLogEntries) */ {
 public:
  CompressedLogEntries();
  virtual ~CompressedLogEntries();

  CompressedLogEntries(const CompressedLogEntries& from);

  inline CompressedLogEntries& operator=(const CompressedLogEntries& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CompressedLogEntries(CompressedLogEntries&& from) noexcept
    : CompressedLogEntries() {
    *this = ::std::move(from);
  }

  inline CompressedLogEntries& operator=(CompressedLogEntries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompressedLogEntries& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompressedLogEntries* internal_default_instance() {
    return reinterpret_cast<const CompressedLogEntries*>(
               &_CompressedLogEntries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CompressedLogEntries* other);
  friend void swap(CompressedLogEntries& a, CompressedLogEntries& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CompressedLogEntries* New() const final {
    return CreateMaybeMessage<CompressedLogEntries>(NULL);
  }

  CompressedLogEntries* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CompressedLogEntries>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CompressedLogEntries& from);
  void MergeFrom(const CompressedLogEntries& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedLogEntries* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 rawSize = 2;
  bool has_rawsize() const;
  void clear_rawsize();
  static const int kRawSizeFieldNumber = 2;
  ::google::protobuf::uint32 rawsize() const;
  void set_rawsize(::google::protobuf::uint32 value);

  // optional uint32 checksum = 4;
  bool has_checksum() const;
  void clear_checksum();
  static const int kChecksumFieldNumber = 4;
  ::google::protobuf::uint32 checksum() const;
  void set_checksum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:alisql.CompressedLogEntries)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_rawsize();
  void clear_has_rawsize();
  void set_has_data();
  void clear_has_data();
  void set_has_checksum();
  void clear_has_checksum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 rawsize_;
  ::google::protobuf::uint32 checksum_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfigureChangeValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.ConfigureChangeValue) */ {
 public:
  ConfigureChangeValue();
  virtual ~ConfigureChangeValue();

  ConfigureChangeValue(const ConfigureChangeValue& from);

  inline ConfigureChangeValue& operator=(const ConfigureChangeValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigureChangeValue(ConfigureChangeValue&& from) noexcept
    : ConfigureChangeValue() {
    *this = ::std::move(from);
  }

  inline ConfigureChangeValue& operator=(ConfigureChangeValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigureChangeValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigureChangeValue* internal_default_instance() {
    return reinterpret_cast<const ConfigureChangeValue*>(
               &_ConfigureChangeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ConfigureChangeValue* other);
  friend void swap(ConfigureChangeValue& a, ConfigureChangeValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigureChangeValue* New() const final {
    return CreateMaybeMessage<ConfigureChangeValue>(NULL);
  }

  ConfigureChangeValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigureChangeValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigureChangeValue& from);
  void MergeFrom(const ConfigureChangeValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigureChangeValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes addrs = 3;
  int addrs_size() const;
  void clear_addrs();
  static const int kAddrsFieldNumber = 3;
  const ::std::string& addrs(int index) const;
  ::std::string* mutable_addrs(int index);
  void set_addrs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_addrs(int index, ::std::string&& value);
  #endif
  void set_addrs(int index, const char* value);
  void set_addrs(int index, const void* value, size_t size);
  ::std::string* add_addrs();
  void add_addrs(const ::std::string& value);
  #if LANG_CXX11
  void add_addrs(::std::string&& value);
  #endif
  void add_addrs(const char* value);
  void add_addrs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& addrs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_addrs();

  // repeated bytes allServers = 4;
  int allservers_size() const;
  void clear_allservers();
  static const int kAllServersFieldNumber = 4;
  const ::std::string& allservers(int index) const;
  ::std::string* mutable_allservers(int index);
  void set_allservers(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_allservers(int index, ::std::string&& value);
  #endif
  void set_allservers(int index, const char* value);
  void set_allservers(int index, const void* value, size_t size);
  ::std::string* add_allservers();
  void add_allservers(const ::std::string& value);
  #if LANG_CXX11
  void add_allservers(::std::string&& value);
  #endif
  void add_allservers(const char* value);
  void add_allservers(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& allservers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_allservers();

  // repeated bytes allLearners = 5;
  int alllearners_size() const;
  void clear_alllearners();
  static const int kAllLearnersFieldNumber = 5;
  const ::std::string& alllearners(int index) const;
  ::std::string* mutable_alllearners(int index);
  void set_alllearners(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_alllearners(int index, ::std::string&& value);
  #endif
  void set_alllearners(int index, const char* value);
  void set_alllearners(int index, const void* value, size_t size);
  ::std::string* add_alllearners();
  void add_alllearners(const ::std::string& value);
  #if LANG_CXX11
  void add_alllearners(::std::string&& value);
  #endif
  void add_alllearners(const char* value);
  void add_alllearners(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& alllearners() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_alllearners();

  // optional int32 ccType = 1;
  bool has_cctype() const;
  void clear_cctype();
  static const int kCcTypeFieldNumber = 1;
  ::google::protobuf::int32 cctype() const;
  void set_cctype(::google::protobuf::int32 value);

  // optional int32 opType = 2;
  bool has_optype() const;
  void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  ::google::protobuf::int32 optype() const;
  void set_optype(::google::protobuf::int32 value);

  // optional uint64 serverId = 6;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIdFieldNumber = 6;
  ::google::protobuf::uint64 serverid() const;
  void set_serverid(::google::protobuf::uint64 value);

  // optional uint32 forceSync = 7;
  bool has_forcesync() const;
  void clear_forcesync();
  static const int kForceSyncFieldNumber = 7;
  ::google::protobuf::uint32 forcesync() const;
  void set_forcesync(::google::protobuf::uint32 value);

  // optional uint32 electionWeight = 8;
  bool has_electionweight() const;
  void clear_electionweight();
  static const int kElectionWeightFieldNumber = 8;
  ::google::protobuf::uint32 electionweight() const;
  void set_electionweight(::google::protobuf::uint32 value);

  // optional uint64 learnerSource = 9;
  bool has_learnersource() const;
  void clear_learnersource();
  static const int kLearnerSourceFieldNumber = 9;
  ::google::protobuf::uint64 learnersource() const;
  void set_learnersource(::google::protobuf::uint64 value);

  // optional bool applyMode = 10;
  bool has_applymode() const;
  void clear_applymode();
  static const int kApplyModeFieldNumber = 10;
  bool applymode() const;
  void set_applymode(bool value);

  // @@protoc_insertion_point(class_scope:alisql.ConfigureChangeValue)
 private:
  void set_has_cctype();
  void clear_has_cctype();
  void set_has_optype();
  void clear_has_optype();
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_forcesync();
  void clear_has_forcesync();
  void set_has_electionweight();
  void clear_has_electionweight();
  void set_has_learnersource();
  void clear_has_learnersource();
  void set_has_applymode();
  void clear_has_applymode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> addrs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> allservers_;
  ::google::protobuf::RepeatedPtrField< ::std::string> alllearners_;
  ::google::protobuf::int32 cctype_;
  ::google::protobuf::int32 optype_;
  ::google::protobuf::uint64 serverid_;
  ::google::protobuf::uint32 forcesync_;
  ::google::protobuf::uint32 electionweight_;
  ::google::protobuf::uint64 learnersource_;
  bool applymode_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClusterInfoEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.ClusterInfoEntry) */ {
 public:
  ClusterInfoEntry();
  virtual ~ClusterInfoEntry();

  ClusterInfoEntry(const ClusterInfoEntry& from);

  inline ClusterInfoEntry& operator=(const ClusterInfoEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusterInfoEntry(ClusterInfoEntry&& from) noexcept
    : ClusterInfoEntry() {
    *this = ::std::move(from);
  }

  inline ClusterInfoEntry& operator=(ClusterInfoEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterInfoEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClusterInfoEntry* internal_default_instance() {
    return reinterpret_cast<const ClusterInfoEntry*>(
               &_ClusterInfoEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ClusterInfoEntry* other);
  friend void swap(ClusterInfoEntry& a, ClusterInfoEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusterInfoEntry* New() const final {
    return CreateMaybeMessage<ClusterInfoEntry>(NULL);
  }

  ClusterInfoEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClusterInfoEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClusterInfoEntry& from);
  void MergeFrom(const ClusterInfoEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterInfoEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 serverId = 1;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIdFieldNumber = 1;
  ::google::protobuf::uint64 serverid() const;
  void set_serverid(::google::protobuf::uint64 value);

  // optional uint64 matchIndex = 2;
  bool has_matchindex() const;
  void clear_matchindex();
  static const int kMatchIndexFieldNumber = 2;
  ::google::protobuf::uint64 matchindex() const;
  void set_matchindex(::google::protobuf::uint64 value);

  // optional uint64 nextIndex = 3;
  bool has_nextindex() const;
  void clear_nextindex();
  static const int kNextIndexFieldNumber = 3;
  ::google::protobuf::uint64 nextindex() const;
  void set_nextindex(::google::protobuf::uint64 value);

  // optional uint64 hasVoted = 5;
  bool has_hasvoted() const;
  void clear_hasvoted();
  static const int kHasVotedFieldNumber = 5;
  ::google::protobuf::uint64 hasvoted() const;
  void set_hasvoted(::google::protobuf::uint64 value);

  // optional uint32 role = 4;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 4;
  ::google::protobuf::uint32 role() const;
  void set_role(::google::protobuf::uint32 value);

  // optional uint32 forceSync = 6;
  bool has_forcesync() const;
  void clear_forcesync();
  static const int kForceSyncFieldNumber = 6;
  ::google::protobuf::uint32 forcesync() const;
  void set_forcesync(::google::protobuf::uint32 value);

  // optional uint64 learnerSource = 8;
  bool has_learnersource() const;
  void clear_learnersource();
  static const int kLearnerSourceFieldNumber = 8;
  ::google::protobuf::uint64 learnersource() const;
  void set_learnersource(::google::protobuf::uint64 value);

  // optional uint32 electionWeight = 7;
  bool has_electionweight() const;
  void clear_electionweight();
  static const int kElectionWeightFieldNumber = 7;
  ::google::protobuf::uint32 electionweight() const;
  void set_electionweight(::google::protobuf::uint32 value);

  // optional uint32 pipelining = 10;
  bool has_pipelining() const;
  void clear_pipelining();
  static const int kPipeliningFieldNumber = 10;
  ::google::protobuf::uint32 pipelining() const;
  void set_pipelining(::google::protobuf::uint32 value);

  // optional uint64 appliedIndex = 9;
  bool has_appliedindex() const;
  void clear_appliedindex();
  static const int kAppliedIndexFieldNumber = 9;
  ::google::protobuf::uint64 appliedindex() const;
  void set_appliedindex(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:alisql.ClusterInfoEntry)
 private:
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_matchindex();
  void clear_has_matchindex();
  void set_has_nextindex();
  void clear_has_nextindex();
  void set_has_role();
  void clear_has_role();
  void set_has_hasvoted();
  void clear_has_hasvoted();
  void set_has_forcesync();
  void clear_has_forcesync();
  void set_has_electionweight();
  void clear_has_electionweight();
  void set_has_learnersource();
  void clear_has_learnersource();
  void set_has_appliedindex();
  void clear_has_appliedindex();
  void set_has_pipelining();
  void clear_has_pipelining();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 serverid_;
  ::google::protobuf::uint64 matchindex_;
  ::google::protobuf::uint64 nextindex_;
  ::google::protobuf::uint64 hasvoted_;
  ::google::protobuf::uint32 role_;
  ::google::protobuf::uint32 forcesync_;
  ::google::protobuf::uint64 learnersource_;
  ::google::protobuf::uint32 electionweight_;
  ::google::protobuf::uint32 pipelining_;
  ::google::protobuf::uint64 appliedindex_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaxosMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.PaxosMsg) */ {
 public:
  PaxosMsg();
  virtual ~PaxosMsg();

  PaxosMsg(const PaxosMsg& from);

  inline PaxosMsg& operator=(const PaxosMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PaxosMsg(PaxosMsg&& from) noexcept
    : PaxosMsg() {
    *this = ::std::move(from);
  }

  inline PaxosMsg& operator=(PaxosMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaxosMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaxosMsg* internal_default_instance() {
    return reinterpret_cast<const PaxosMsg*>(
               &_PaxosMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PaxosMsg* other);
  friend void swap(PaxosMsg& a, PaxosMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PaxosMsg* New() const final {
    return CreateMaybeMessage<PaxosMsg>(NULL);
  }

  PaxosMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PaxosMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PaxosMsg& from);
  void MergeFrom(const PaxosMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaxosMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PaxosMsg_MsgErrorType MsgErrorType;
  static const MsgErrorType NONE =
    PaxosMsg_MsgErrorType_NONE;
  static const MsgErrorType APPEND =
    PaxosMsg_MsgErrorType_APPEND;
  static inline bool MsgErrorType_IsValid(int value) {
    return PaxosMsg_MsgErrorType_IsValid(value);
  }
  static const MsgErrorType MsgErrorType_MIN =
    PaxosMsg_MsgErrorType_MsgErrorType_MIN;
  static const MsgErrorType MsgErrorType_MAX =
    PaxosMsg_MsgErrorType_MsgErrorType_MAX;
  static const int MsgErrorType_ARRAYSIZE =
    PaxosMsg_MsgErrorType_MsgErrorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgErrorType_descriptor() {
    return PaxosMsg_MsgErrorType_descriptor();
  }
  static inline const ::std::string& MsgErrorType_Name(MsgErrorType value) {
    return PaxosMsg_MsgErrorType_Name(value);
  }
  static inline bool MsgErrorType_Parse(const ::std::string& name,
      MsgErrorType* value) {
    return PaxosMsg_MsgErrorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .alisql.LogEntry entries = 10;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 10;
  ::alisql::LogEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::alisql::LogEntry >*
      mutable_entries();
  const ::alisql::LogEntry& entries(int index) const;
  ::alisql::LogEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::alisql::LogEntry >&
      entries() const;

  // repeated .alisql.ClusterInfoEntry ciEntries = 25;
  int cientries_size() const;
  void clear_cientries();
  static const int kCiEntriesFieldNumber = 25;
  ::alisql::ClusterInfoEntry* mutable_cientries(int index);
  ::google::protobuf::RepeatedPtrField< ::alisql::ClusterInfoEntry >*
      mutable_cientries();
  const ::alisql::ClusterInfoEntry& cientries(int index) const;
  ::alisql::ClusterInfoEntry* add_cientries();
  const ::google::protobuf::RepeatedPtrField< ::alisql::ClusterInfoEntry >&
      cientries() const;

  // optional bytes addr = 18;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 18;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const void* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // optional bytes extra = 28;
  bool has_extra() const;
  void clear_extra();
  static const int kExtraFieldNumber = 28;
  const ::std::string& extra() const;
  void set_extra(const ::std::string& value);
  #if LANG_CXX11
  void set_extra(::std::string&& value);
  #endif
  void set_extra(const char* value);
  void set_extra(const void* value, size_t size);
  ::std::string* mutable_extra();
  ::std::string* release_extra();
  void set_allocated_extra(::std::string* extra);

  // optional .alisql.CompressedLogEntries compressedEntries = 27;
  bool has_compressedentries() const;
  void clear_compressedentries();
  static const int kCompressedEntriesFieldNumber = 27;
  private:
  const ::alisql::CompressedLogEntries& _internal_compressedentries() const;
  public:
  const ::alisql::CompressedLogEntries& compressedentries() const;
  ::alisql::CompressedLogEntries* release_compressedentries();
  ::alisql::CompressedLogEntries* mutable_compressedentries();
  void set_allocated_compressedentries(::alisql::CompressedLogEntries* compressedentries);

  // optional uint64 configId = 1;
  bool has_configid() const;
  void clear_configid();
  static const int kConfigIdFieldNumber = 1;
  ::google::protobuf::uint64 configid() const;
  void set_configid(::google::protobuf::uint64 value);

  // required uint64 clusterId = 2;
  bool has_clusterid() const;
  void clear_clusterid();
  static const int kClusterIdFieldNumber = 2;
  ::google::protobuf::uint64 clusterid() const;
  void set_clusterid(::google::protobuf::uint64 value);

  // required uint64 serverId = 3;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIdFieldNumber = 3;
  ::google::protobuf::uint64 serverid() const;
  void set_serverid(::google::protobuf::uint64 value);

  // required uint64 term = 5;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 5;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // required uint64 msgId = 6;
  bool has_msgid() const;
  void clear_msgid();
  static const int kMsgIdFieldNumber = 6;
  ::google::protobuf::uint64 msgid() const;
  void set_msgid(::google::protobuf::uint64 value);

  // optional uint64 leaderId = 7;
  bool has_leaderid() const;
  void clear_leaderid();
  static const int kLeaderIdFieldNumber = 7;
  ::google::protobuf::uint64 leaderid() const;
  void set_leaderid(::google::protobuf::uint64 value);

  // optional uint64 prevLogIndex = 8;
  bool has_prevlogindex() const;
  void clear_prevlogindex();
  static const int kPrevLogIndexFieldNumber = 8;
  ::google::protobuf::uint64 prevlogindex() const;
  void set_prevlogindex(::google::protobuf::uint64 value);

  // optional uint64 prevLogTerm = 9;
  bool has_prevlogterm() const;
  void clear_prevlogterm();
  static const int kPrevLogTermFieldNumber = 9;
  ::google::protobuf::uint64 prevlogterm() const;
  void set_prevlogterm(::google::protobuf::uint64 value);

  // optional uint64 commitIndex = 11;
  bool has_commitindex() const;
  void clear_commitindex();
  static const int kCommitIndexFieldNumber = 11;
  ::google::protobuf::uint64 commitindex() const;
  void set_commitindex(::google::protobuf::uint64 value);

  // required int32 msgType = 4;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 4;
  ::google::protobuf::int32 msgtype() const;
  void set_msgtype(::google::protobuf::int32 value);

  // optional bool nocache = 12;
  bool has_nocache() const;
  void clear_nocache();
  static const int kNocacheFieldNumber = 12;
  bool nocache() const;
  void set_nocache(bool value);

  // optional bool isSuccess = 13;
  bool has_issuccess() const;
  void clear_issuccess();
  static const int kIsSuccessFieldNumber = 13;
  bool issuccess() const;
  void set_issuccess(bool value);

  // optional bool voteGranted = 19;
  bool has_votegranted() const;
  void clear_votegranted();
  static const int kVoteGrantedFieldNumber = 19;
  bool votegranted() const;
  void set_votegranted(bool value);

  // optional bool ignoreCheck = 20;
  bool has_ignorecheck() const;
  void clear_ignorecheck();
  static const int kIgnoreCheckFieldNumber = 20;
  bool ignorecheck() const;
  void set_ignorecheck(bool value);

  // optional uint64 candidateId = 14;
  bool has_candidateid() const;
  void clear_candidateid();
  static const int kCandidateIdFieldNumber = 14;
  ::google::protobuf::uint64 candidateid() const;
  void set_candidateid(::google::protobuf::uint64 value);

  // optional uint64 lastLogIndex = 15;
  bool has_lastlogindex() const;
  void clear_lastlogindex();
  static const int kLastLogIndexFieldNumber = 15;
  ::google::protobuf::uint64 lastlogindex() const;
  void set_lastlogindex(::google::protobuf::uint64 value);

  // optional uint64 lastLogTerm = 16;
  bool has_lastlogterm() const;
  void clear_lastlogterm();
  static const int kLastLogTermFieldNumber = 16;
  ::google::protobuf::uint64 lastlogterm() const;
  void set_lastlogterm(::google::protobuf::uint64 value);

  // optional uint64 force = 17;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 17;
  ::google::protobuf::uint64 force() const;
  void set_force(::google::protobuf::uint64 value);

  // optional uint64 lcType = 21;
  bool has_lctype() const;
  void clear_lctype();
  static const int kLcTypeFieldNumber = 21;
  ::google::protobuf::uint64 lctype() const;
  void set_lctype(::google::protobuf::uint64 value);

  // optional uint64 minMatchIndex = 22;
  bool has_minmatchindex() const;
  void clear_minmatchindex();
  static const int kMinMatchIndexFieldNumber = 22;
  ::google::protobuf::uint64 minmatchindex() const;
  void set_minmatchindex(::google::protobuf::uint64 value);

  // optional uint64 appliedIndex = 23;
  bool has_appliedindex() const;
  void clear_appliedindex();
  static const int kAppliedIndexFieldNumber = 23;
  ::google::protobuf::uint64 appliedindex() const;
  void set_appliedindex(::google::protobuf::uint64 value);

  // optional uint64 newClusterId = 24;
  bool has_newclusterid() const;
  void clear_newclusterid();
  static const int kNewClusterIdFieldNumber = 24;
  ::google::protobuf::uint64 newclusterid() const;
  void set_newclusterid(::google::protobuf::uint64 value);

  // optional uint32 role = 26;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 26;
  ::google::protobuf::uint32 role() const;
  void set_role(::google::protobuf::uint32 value);

  // optional .alisql.PaxosMsg.MsgErrorType msgError = 30;
  bool has_msgerror() const;
  void clear_msgerror();
  static const int kMsgErrorFieldNumber = 30;
  ::alisql::PaxosMsg_MsgErrorType msgerror() const;
  void set_msgerror(::alisql::PaxosMsg_MsgErrorType value);

  // @@protoc_insertion_point(class_scope:alisql.PaxosMsg)
 private:
  void set_has_configid();
  void clear_has_configid();
  void set_has_clusterid();
  void clear_has_clusterid();
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_term();
  void clear_has_term();
  void set_has_msgid();
  void clear_has_msgid();
  void set_has_leaderid();
  void clear_has_leaderid();
  void set_has_prevlogindex();
  void clear_has_prevlogindex();
  void set_has_prevlogterm();
  void clear_has_prevlogterm();
  void set_has_commitindex();
  void clear_has_commitindex();
  void set_has_nocache();
  void clear_has_nocache();
  void set_has_issuccess();
  void clear_has_issuccess();
  void set_has_candidateid();
  void clear_has_candidateid();
  void set_has_lastlogindex();
  void clear_has_lastlogindex();
  void set_has_lastlogterm();
  void clear_has_lastlogterm();
  void set_has_force();
  void clear_has_force();
  void set_has_addr();
  void clear_has_addr();
  void set_has_votegranted();
  void clear_has_votegranted();
  void set_has_ignorecheck();
  void clear_has_ignorecheck();
  void set_has_lctype();
  void clear_has_lctype();
  void set_has_minmatchindex();
  void clear_has_minmatchindex();
  void set_has_appliedindex();
  void clear_has_appliedindex();
  void set_has_newclusterid();
  void clear_has_newclusterid();
  void set_has_role();
  void clear_has_role();
  void set_has_compressedentries();
  void clear_has_compressedentries();
  void set_has_extra();
  void clear_has_extra();
  void set_has_msgerror();
  void clear_has_msgerror();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::alisql::LogEntry > entries_;
  ::google::protobuf::RepeatedPtrField< ::alisql::ClusterInfoEntry > cientries_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::internal::ArenaStringPtr extra_;
  ::alisql::CompressedLogEntries* compressedentries_;
  ::google::protobuf::uint64 configid_;
  ::google::protobuf::uint64 clusterid_;
  ::google::protobuf::uint64 serverid_;
  ::google::protobuf::uint64 term_;
  ::google::protobuf::uint64 msgid_;
  ::google::protobuf::uint64 leaderid_;
  ::google::protobuf::uint64 prevlogindex_;
  ::google::protobuf::uint64 prevlogterm_;
  ::google::protobuf::uint64 commitindex_;
  ::google::protobuf::int32 msgtype_;
  bool nocache_;
  bool issuccess_;
  bool votegranted_;
  bool ignorecheck_;
  ::google::protobuf::uint64 candidateid_;
  ::google::protobuf::uint64 lastlogindex_;
  ::google::protobuf::uint64 lastlogterm_;
  ::google::protobuf::uint64 force_;
  ::google::protobuf::uint64 lctype_;
  ::google::protobuf::uint64 minmatchindex_;
  ::google::protobuf::uint64 appliedindex_;
  ::google::protobuf::uint64 newclusterid_;
  ::google::protobuf::uint32 role_;
  int msgerror_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestMsg1 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.TestMsg1) */ {
 public:
  TestMsg1();
  virtual ~TestMsg1();

  TestMsg1(const TestMsg1& from);

  inline TestMsg1& operator=(const TestMsg1& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestMsg1(TestMsg1&& from) noexcept
    : TestMsg1() {
    *this = ::std::move(from);
  }

  inline TestMsg1& operator=(TestMsg1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestMsg1& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestMsg1* internal_default_instance() {
    return reinterpret_cast<const TestMsg1*>(
               &_TestMsg1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TestMsg1* other);
  friend void swap(TestMsg1& a, TestMsg1& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestMsg1* New() const final {
    return CreateMaybeMessage<TestMsg1>(NULL);
  }

  TestMsg1* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestMsg1>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestMsg1& from);
  void MergeFrom(const TestMsg1& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMsg1* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional uint64 c1 = 2;
  bool has_c1() const;
  void clear_c1();
  static const int kC1FieldNumber = 2;
  ::google::protobuf::uint64 c1() const;
  void set_c1(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:alisql.TestMsg1)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_c1();
  void clear_has_c1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 c1_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestMsg2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alisql.TestMsg2) */ {
 public:
  TestMsg2();
  virtual ~TestMsg2();

  TestMsg2(const TestMsg2& from);

  inline TestMsg2& operator=(const TestMsg2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestMsg2(TestMsg2&& from) noexcept
    : TestMsg2() {
    *this = ::std::move(from);
  }

  inline TestMsg2& operator=(TestMsg2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestMsg2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestMsg2* internal_default_instance() {
    return reinterpret_cast<const TestMsg2*>(
               &_TestMsg2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TestMsg2* other);
  friend void swap(TestMsg2& a, TestMsg2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestMsg2* New() const final {
    return CreateMaybeMessage<TestMsg2>(NULL);
  }

  TestMsg2* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestMsg2>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestMsg2& from);
  void MergeFrom(const TestMsg2& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMsg2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 c2 = 3;
  int c2_size() const;
  void clear_c2();
  static const int kC2FieldNumber = 3;
  ::google::protobuf::uint64 c2(int index) const;
  void set_c2(int index, ::google::protobuf::uint64 value);
  void add_c2(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      c2() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_c2();

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional uint64 c1 = 2;
  bool has_c1() const;
  void clear_c1();
  static const int kC1FieldNumber = 2;
  ::google::protobuf::uint64 c1() const;
  void set_c1(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:alisql.TestMsg2)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_c1();
  void clear_has_c1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > c2_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 c1_;
  friend struct ::protobuf_paxos_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogEntry

// required uint64 term = 1;
inline bool LogEntry::has_term() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogEntry::set_has_term() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogEntry::clear_has_term() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogEntry::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 LogEntry::term() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.term)
  return term_;
}
inline void LogEntry::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:alisql.LogEntry.term)
}

// required uint64 index = 2;
inline bool LogEntry::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogEntry::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogEntry::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogEntry::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 LogEntry::index() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.index)
  return index_;
}
inline void LogEntry::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:alisql.LogEntry.index)
}

// required uint64 opType = 3;
inline bool LogEntry::has_optype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogEntry::set_has_optype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogEntry::clear_has_optype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogEntry::clear_optype() {
  optype_ = GOOGLE_ULONGLONG(0);
  clear_has_optype();
}
inline ::google::protobuf::uint64 LogEntry::optype() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.opType)
  return optype_;
}
inline void LogEntry::set_optype(::google::protobuf::uint64 value) {
  set_has_optype();
  optype_ = value;
  // @@protoc_insertion_point(field_set:alisql.LogEntry.opType)
}

// optional bytes ikey = 4;
inline bool LogEntry::has_ikey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEntry::set_has_ikey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEntry::clear_has_ikey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEntry::clear_ikey() {
  ikey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ikey();
}
inline const ::std::string& LogEntry::ikey() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.ikey)
  return ikey_.GetNoArena();
}
inline void LogEntry::set_ikey(const ::std::string& value) {
  set_has_ikey();
  ikey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alisql.LogEntry.ikey)
}
#if LANG_CXX11
inline void LogEntry::set_ikey(::std::string&& value) {
  set_has_ikey();
  ikey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alisql.LogEntry.ikey)
}
#endif
inline void LogEntry::set_ikey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ikey();
  ikey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alisql.LogEntry.ikey)
}
inline void LogEntry::set_ikey(const void* value, size_t size) {
  set_has_ikey();
  ikey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alisql.LogEntry.ikey)
}
inline ::std::string* LogEntry::mutable_ikey() {
  set_has_ikey();
  // @@protoc_insertion_point(field_mutable:alisql.LogEntry.ikey)
  return ikey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_ikey() {
  // @@protoc_insertion_point(field_release:alisql.LogEntry.ikey)
  if (!has_ikey()) {
    return NULL;
  }
  clear_has_ikey();
  return ikey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_ikey(::std::string* ikey) {
  if (ikey != NULL) {
    set_has_ikey();
  } else {
    clear_has_ikey();
  }
  ikey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ikey);
  // @@protoc_insertion_point(field_set_allocated:alisql.LogEntry.ikey)
}

// optional bytes value = 5;
inline bool LogEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& LogEntry::value() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.value)
  return value_.GetNoArena();
}
inline void LogEntry::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alisql.LogEntry.value)
}
#if LANG_CXX11
inline void LogEntry::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alisql.LogEntry.value)
}
#endif
inline void LogEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alisql.LogEntry.value)
}
inline void LogEntry::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alisql.LogEntry.value)
}
inline ::std::string* LogEntry::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:alisql.LogEntry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_value() {
  // @@protoc_insertion_point(field_release:alisql.LogEntry.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:alisql.LogEntry.value)
}

// optional uint64 info = 6;
inline bool LogEntry::has_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogEntry::set_has_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogEntry::clear_has_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogEntry::clear_info() {
  info_ = GOOGLE_ULONGLONG(0);
  clear_has_info();
}
inline ::google::protobuf::uint64 LogEntry::info() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.info)
  return info_;
}
inline void LogEntry::set_info(::google::protobuf::uint64 value) {
  set_has_info();
  info_ = value;
  // @@protoc_insertion_point(field_set:alisql.LogEntry.info)
}

// optional uint64 checksum = 7;
inline bool LogEntry::has_checksum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogEntry::set_has_checksum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogEntry::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogEntry::clear_checksum() {
  checksum_ = GOOGLE_ULONGLONG(0);
  clear_has_checksum();
}
inline ::google::protobuf::uint64 LogEntry::checksum() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.checksum)
  return checksum_;
}
inline void LogEntry::set_checksum(::google::protobuf::uint64 value) {
  set_has_checksum();
  checksum_ = value;
  // @@protoc_insertion_point(field_set:alisql.LogEntry.checksum)
}

// optional bytes opaque = 9;
inline bool LogEntry::has_opaque() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogEntry::set_has_opaque() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogEntry::clear_has_opaque() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogEntry::clear_opaque() {
  opaque_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_opaque();
}
inline const ::std::string& LogEntry::opaque() const {
  // @@protoc_insertion_point(field_get:alisql.LogEntry.opaque)
  return opaque_.GetNoArena();
}
inline void LogEntry::set_opaque(const ::std::string& value) {
  set_has_opaque();
  opaque_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alisql.LogEntry.opaque)
}
#if LANG_CXX11
inline void LogEntry::set_opaque(::std::string&& value) {
  set_has_opaque();
  opaque_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alisql.LogEntry.opaque)
}
#endif
inline void LogEntry::set_opaque(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_opaque();
  opaque_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alisql.LogEntry.opaque)
}
inline void LogEntry::set_opaque(const void* value, size_t size) {
  set_has_opaque();
  opaque_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alisql.LogEntry.opaque)
}
inline ::std::string* LogEntry::mutable_opaque() {
  set_has_opaque();
  // @@protoc_insertion_point(field_mutable:alisql.LogEntry.opaque)
  return opaque_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_opaque() {
  // @@protoc_insertion_point(field_release:alisql.LogEntry.opaque)
  if (!has_opaque()) {
    return NULL;
  }
  clear_has_opaque();
  return opaque_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_opaque(::std::string* opaque) {
  if (opaque != NULL) {
    set_has_opaque();
  } else {
    clear_has_opaque();
  }
  opaque_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opaque);
  // @@protoc_insertion_point(field_set_allocated:alisql.LogEntry.opaque)
}

// -------------------------------------------------------------------

// RDSFields

// optional uint32 rdsServerId = 1;
inline bool RDSFields::has_rdsserverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RDSFields::set_has_rdsserverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RDSFields::clear_has_rdsserverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RDSFields::clear_rdsserverid() {
  rdsserverid_ = 0u;
  clear_has_rdsserverid();
}
inline ::google::protobuf::uint32 RDSFields::rdsserverid() const {
  // @@protoc_insertion_point(field_get:alisql.RDSFields.rdsServerId)
  return rdsserverid_;
}
inline void RDSFields::set_rdsserverid(::google::protobuf::uint32 value) {
  set_has_rdsserverid();
  rdsserverid_ = value;
  // @@protoc_insertion_point(field_set:alisql.RDSFields.rdsServerId)
}

// optional uint32 source = 2;
inline bool RDSFields::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RDSFields::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RDSFields::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RDSFields::clear_source() {
  source_ = 0u;
  clear_has_source();
}
inline ::google::protobuf::uint32 RDSFields::source() const {
  // @@protoc_insertion_point(field_get:alisql.RDSFields.source)
  return source_;
}
inline void RDSFields::set_source(::google::protobuf::uint32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:alisql.RDSFields.source)
}

// -------------------------------------------------------------------

// PolarFields

// required uint32 version = 1;
inline bool PolarFields::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolarFields::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PolarFields::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PolarFields::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 PolarFields::version() const {
  // @@protoc_insertion_point(field_get:alisql.PolarFields.version)
  return version_;
}
inline void PolarFields::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:alisql.PolarFields.version)
}

// required uint64 start_lsn = 2;
inline bool PolarFields::has_start_lsn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolarFields::set_has_start_lsn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PolarFields::clear_has_start_lsn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PolarFields::clear_start_lsn() {
  start_lsn_ = GOOGLE_ULONGLONG(0);
  clear_has_start_lsn();
}
inline ::google::protobuf::uint64 PolarFields::start_lsn() const {
  // @@protoc_insertion_point(field_get:alisql.PolarFields.start_lsn)
  return start_lsn_;
}
inline void PolarFields::set_start_lsn(::google::protobuf::uint64 value) {
  set_has_start_lsn();
  start_lsn_ = value;
  // @@protoc_insertion_point(field_set:alisql.PolarFields.start_lsn)
}

// optional bytes extra_value = 3;
inline bool PolarFields::has_extra_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolarFields::set_has_extra_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PolarFields::clear_has_extra_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PolarFields::clear_extra_value() {
  extra_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extra_value();
}
inline const ::std::string& PolarFields::extra_value() const {
  // @@protoc_insertion_point(field_get:alisql.PolarFields.extra_value)
  return extra_value_.GetNoArena();
}
inline void PolarFields::set_extra_value(const ::std::string& value) {
  set_has_extra_value();
  extra_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alisql.PolarFields.extra_value)
}
#if LANG_CXX11
inline void PolarFields::set_extra_value(::std::string&& value) {
  set_has_extra_value();
  extra_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alisql.PolarFields.extra_value)
}
#endif
inline void PolarFields::set_extra_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extra_value();
  extra_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alisql.PolarFields.extra_value)
}
inline void PolarFields::set_extra_value(const void* value, size_t size) {
  set_has_extra_value();
  extra_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alisql.PolarFields.extra_value)
}
inline ::std::string* PolarFields::mutable_extra_value() {
  set_has_extra_value();
  // @@protoc_insertion_point(field_mutable:alisql.PolarFields.extra_value)
  return extra_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PolarFields::release_extra_value() {
  // @@protoc_insertion_point(field_release:alisql.PolarFields.extra_value)
  if (!has_extra_value()) {
    return NULL;
  }
  clear_has_extra_value();
  return extra_value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PolarFields::set_allocated_extra_value(::std::string* extra_value) {
  if (extra_value != NULL) {
    set_has_extra_value();
  } else {
    clear_has_extra_value();
  }
  extra_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_value);
  // @@protoc_insertion_point(field_set_allocated:alisql.PolarFields.extra_value)
}

// -------------------------------------------------------------------

// CompressedLogEntries

// required uint32 type = 1;
inline bool CompressedLogEntries::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompressedLogEntries::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompressedLogEntries::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompressedLogEntries::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CompressedLogEntries::type() const {
  // @@protoc_insertion_point(field_get:alisql.CompressedLogEntries.type)
  return type_;
}
inline void CompressedLogEntries::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:alisql.CompressedLogEntries.type)
}

// required uint32 rawSize = 2;
inline bool CompressedLogEntries::has_rawsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompressedLogEntries::set_has_rawsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompressedLogEntries::clear_has_rawsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompressedLogEntries::clear_rawsize() {
  rawsize_ = 0u;
  clear_has_rawsize();
}
inline ::google::protobuf::uint32 CompressedLogEntries::rawsize() const {
  // @@protoc_insertion_point(field_get:alisql.CompressedLogEntries.rawSize)
  return rawsize_;
}
inline void CompressedLogEntries::set_rawsize(::google::protobuf::uint32 value) {
  set_has_rawsize();
  rawsize_ = value;
  // @@protoc_insertion_point(field_set:alisql.CompressedLogEntries.rawSize)
}

// required bytes data = 3;
inline bool CompressedLogEntries::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompressedLogEntries::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompressedLogEntries::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompressedLogEntries::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CompressedLogEntries::data() const {
  // @@protoc_insertion_point(field_get:alisql.CompressedLogEntries.data)
  return data_.GetNoArena();
}
inline void CompressedLogEntries::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alisql.CompressedLogEntries.data)
}
#if LANG_CXX11
inline void CompressedLogEntries::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alisql.CompressedLogEntries.data)
}
#endif
inline void CompressedLogEntries::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alisql.CompressedLogEntries.data)
}
inline void CompressedLogEntries::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alisql.CompressedLogEntries.data)
}
inline ::std::string* CompressedLogEntries::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:alisql.CompressedLogEntries.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CompressedLogEntries::release_data() {
  // @@protoc_insertion_point(field_release:alisql.CompressedLogEntries.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CompressedLogEntries::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:alisql.CompressedLogEntries.data)
}

// optional uint32 checksum = 4;
inline bool CompressedLogEntries::has_checksum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CompressedLogEntries::set_has_checksum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CompressedLogEntries::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CompressedLogEntries::clear_checksum() {
  checksum_ = 0u;
  clear_has_checksum();
}
inline ::google::protobuf::uint32 CompressedLogEntries::checksum() const {
  // @@protoc_insertion_point(field_get:alisql.CompressedLogEntries.checksum)
  return checksum_;
}
inline void CompressedLogEntries::set_checksum(::google::protobuf::uint32 value) {
  set_has_checksum();
  checksum_ = value;
  // @@protoc_insertion_point(field_set:alisql.CompressedLogEntries.checksum)
}

// -------------------------------------------------------------------

// ConfigureChangeValue

// optional int32 ccType = 1;
inline bool ConfigureChangeValue::has_cctype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigureChangeValue::set_has_cctype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigureChangeValue::clear_has_cctype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigureChangeValue::clear_cctype() {
  cctype_ = 0;
  clear_has_cctype();
}
inline ::google::protobuf::int32 ConfigureChangeValue::cctype() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.ccType)
  return cctype_;
}
inline void ConfigureChangeValue::set_cctype(::google::protobuf::int32 value) {
  set_has_cctype();
  cctype_ = value;
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.ccType)
}

// optional int32 opType = 2;
inline bool ConfigureChangeValue::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigureChangeValue::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigureChangeValue::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigureChangeValue::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::google::protobuf::int32 ConfigureChangeValue::optype() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.opType)
  return optype_;
}
inline void ConfigureChangeValue::set_optype(::google::protobuf::int32 value) {
  set_has_optype();
  optype_ = value;
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.opType)
}

// repeated bytes addrs = 3;
inline int ConfigureChangeValue::addrs_size() const {
  return addrs_.size();
}
inline void ConfigureChangeValue::clear_addrs() {
  addrs_.Clear();
}
inline const ::std::string& ConfigureChangeValue::addrs(int index) const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.addrs)
  return addrs_.Get(index);
}
inline ::std::string* ConfigureChangeValue::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.ConfigureChangeValue.addrs)
  return addrs_.Mutable(index);
}
inline void ConfigureChangeValue::set_addrs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.addrs)
  addrs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ConfigureChangeValue::set_addrs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.addrs)
  addrs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ConfigureChangeValue::set_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alisql.ConfigureChangeValue.addrs)
}
inline void ConfigureChangeValue::set_addrs(int index, const void* value, size_t size) {
  addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alisql.ConfigureChangeValue.addrs)
}
inline ::std::string* ConfigureChangeValue::add_addrs() {
  // @@protoc_insertion_point(field_add_mutable:alisql.ConfigureChangeValue.addrs)
  return addrs_.Add();
}
inline void ConfigureChangeValue::add_addrs(const ::std::string& value) {
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.addrs)
}
#if LANG_CXX11
inline void ConfigureChangeValue::add_addrs(::std::string&& value) {
  addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.addrs)
}
#endif
inline void ConfigureChangeValue::add_addrs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alisql.ConfigureChangeValue.addrs)
}
inline void ConfigureChangeValue::add_addrs(const void* value, size_t size) {
  addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alisql.ConfigureChangeValue.addrs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ConfigureChangeValue::addrs() const {
  // @@protoc_insertion_point(field_list:alisql.ConfigureChangeValue.addrs)
  return addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ConfigureChangeValue::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:alisql.ConfigureChangeValue.addrs)
  return &addrs_;
}

// repeated bytes allServers = 4;
inline int ConfigureChangeValue::allservers_size() const {
  return allservers_.size();
}
inline void ConfigureChangeValue::clear_allservers() {
  allservers_.Clear();
}
inline const ::std::string& ConfigureChangeValue::allservers(int index) const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.allServers)
  return allservers_.Get(index);
}
inline ::std::string* ConfigureChangeValue::mutable_allservers(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.ConfigureChangeValue.allServers)
  return allservers_.Mutable(index);
}
inline void ConfigureChangeValue::set_allservers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.allServers)
  allservers_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ConfigureChangeValue::set_allservers(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.allServers)
  allservers_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ConfigureChangeValue::set_allservers(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allservers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alisql.ConfigureChangeValue.allServers)
}
inline void ConfigureChangeValue::set_allservers(int index, const void* value, size_t size) {
  allservers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alisql.ConfigureChangeValue.allServers)
}
inline ::std::string* ConfigureChangeValue::add_allservers() {
  // @@protoc_insertion_point(field_add_mutable:alisql.ConfigureChangeValue.allServers)
  return allservers_.Add();
}
inline void ConfigureChangeValue::add_allservers(const ::std::string& value) {
  allservers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.allServers)
}
#if LANG_CXX11
inline void ConfigureChangeValue::add_allservers(::std::string&& value) {
  allservers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.allServers)
}
#endif
inline void ConfigureChangeValue::add_allservers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allservers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alisql.ConfigureChangeValue.allServers)
}
inline void ConfigureChangeValue::add_allservers(const void* value, size_t size) {
  allservers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alisql.ConfigureChangeValue.allServers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ConfigureChangeValue::allservers() const {
  // @@protoc_insertion_point(field_list:alisql.ConfigureChangeValue.allServers)
  return allservers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ConfigureChangeValue::mutable_allservers() {
  // @@protoc_insertion_point(field_mutable_list:alisql.ConfigureChangeValue.allServers)
  return &allservers_;
}

// repeated bytes allLearners = 5;
inline int ConfigureChangeValue::alllearners_size() const {
  return alllearners_.size();
}
inline void ConfigureChangeValue::clear_alllearners() {
  alllearners_.Clear();
}
inline const ::std::string& ConfigureChangeValue::alllearners(int index) const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.allLearners)
  return alllearners_.Get(index);
}
inline ::std::string* ConfigureChangeValue::mutable_alllearners(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.ConfigureChangeValue.allLearners)
  return alllearners_.Mutable(index);
}
inline void ConfigureChangeValue::set_alllearners(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.allLearners)
  alllearners_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ConfigureChangeValue::set_alllearners(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.allLearners)
  alllearners_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ConfigureChangeValue::set_alllearners(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  alllearners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alisql.ConfigureChangeValue.allLearners)
}
inline void ConfigureChangeValue::set_alllearners(int index, const void* value, size_t size) {
  alllearners_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alisql.ConfigureChangeValue.allLearners)
}
inline ::std::string* ConfigureChangeValue::add_alllearners() {
  // @@protoc_insertion_point(field_add_mutable:alisql.ConfigureChangeValue.allLearners)
  return alllearners_.Add();
}
inline void ConfigureChangeValue::add_alllearners(const ::std::string& value) {
  alllearners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.allLearners)
}
#if LANG_CXX11
inline void ConfigureChangeValue::add_alllearners(::std::string&& value) {
  alllearners_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alisql.ConfigureChangeValue.allLearners)
}
#endif
inline void ConfigureChangeValue::add_alllearners(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  alllearners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alisql.ConfigureChangeValue.allLearners)
}
inline void ConfigureChangeValue::add_alllearners(const void* value, size_t size) {
  alllearners_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alisql.ConfigureChangeValue.allLearners)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ConfigureChangeValue::alllearners() const {
  // @@protoc_insertion_point(field_list:alisql.ConfigureChangeValue.allLearners)
  return alllearners_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ConfigureChangeValue::mutable_alllearners() {
  // @@protoc_insertion_point(field_mutable_list:alisql.ConfigureChangeValue.allLearners)
  return &alllearners_;
}

// optional uint64 serverId = 6;
inline bool ConfigureChangeValue::has_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigureChangeValue::set_has_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigureChangeValue::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigureChangeValue::clear_serverid() {
  serverid_ = GOOGLE_ULONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::uint64 ConfigureChangeValue::serverid() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.serverId)
  return serverid_;
}
inline void ConfigureChangeValue::set_serverid(::google::protobuf::uint64 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.serverId)
}

// optional uint32 forceSync = 7;
inline bool ConfigureChangeValue::has_forcesync() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConfigureChangeValue::set_has_forcesync() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConfigureChangeValue::clear_has_forcesync() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConfigureChangeValue::clear_forcesync() {
  forcesync_ = 0u;
  clear_has_forcesync();
}
inline ::google::protobuf::uint32 ConfigureChangeValue::forcesync() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.forceSync)
  return forcesync_;
}
inline void ConfigureChangeValue::set_forcesync(::google::protobuf::uint32 value) {
  set_has_forcesync();
  forcesync_ = value;
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.forceSync)
}

// optional uint32 electionWeight = 8;
inline bool ConfigureChangeValue::has_electionweight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConfigureChangeValue::set_has_electionweight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConfigureChangeValue::clear_has_electionweight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConfigureChangeValue::clear_electionweight() {
  electionweight_ = 0u;
  clear_has_electionweight();
}
inline ::google::protobuf::uint32 ConfigureChangeValue::electionweight() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.electionWeight)
  return electionweight_;
}
inline void ConfigureChangeValue::set_electionweight(::google::protobuf::uint32 value) {
  set_has_electionweight();
  electionweight_ = value;
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.electionWeight)
}

// optional uint64 learnerSource = 9;
inline bool ConfigureChangeValue::has_learnersource() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConfigureChangeValue::set_has_learnersource() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConfigureChangeValue::clear_has_learnersource() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConfigureChangeValue::clear_learnersource() {
  learnersource_ = GOOGLE_ULONGLONG(0);
  clear_has_learnersource();
}
inline ::google::protobuf::uint64 ConfigureChangeValue::learnersource() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.learnerSource)
  return learnersource_;
}
inline void ConfigureChangeValue::set_learnersource(::google::protobuf::uint64 value) {
  set_has_learnersource();
  learnersource_ = value;
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.learnerSource)
}

// optional bool applyMode = 10;
inline bool ConfigureChangeValue::has_applymode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConfigureChangeValue::set_has_applymode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConfigureChangeValue::clear_has_applymode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConfigureChangeValue::clear_applymode() {
  applymode_ = false;
  clear_has_applymode();
}
inline bool ConfigureChangeValue::applymode() const {
  // @@protoc_insertion_point(field_get:alisql.ConfigureChangeValue.applyMode)
  return applymode_;
}
inline void ConfigureChangeValue::set_applymode(bool value) {
  set_has_applymode();
  applymode_ = value;
  // @@protoc_insertion_point(field_set:alisql.ConfigureChangeValue.applyMode)
}

// -------------------------------------------------------------------

// ClusterInfoEntry

// required uint64 serverId = 1;
inline bool ClusterInfoEntry::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterInfoEntry::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterInfoEntry::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterInfoEntry::clear_serverid() {
  serverid_ = GOOGLE_ULONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::uint64 ClusterInfoEntry::serverid() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.serverId)
  return serverid_;
}
inline void ClusterInfoEntry::set_serverid(::google::protobuf::uint64 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.serverId)
}

// optional uint64 matchIndex = 2;
inline bool ClusterInfoEntry::has_matchindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClusterInfoEntry::set_has_matchindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClusterInfoEntry::clear_has_matchindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClusterInfoEntry::clear_matchindex() {
  matchindex_ = GOOGLE_ULONGLONG(0);
  clear_has_matchindex();
}
inline ::google::protobuf::uint64 ClusterInfoEntry::matchindex() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.matchIndex)
  return matchindex_;
}
inline void ClusterInfoEntry::set_matchindex(::google::protobuf::uint64 value) {
  set_has_matchindex();
  matchindex_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.matchIndex)
}

// optional uint64 nextIndex = 3;
inline bool ClusterInfoEntry::has_nextindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClusterInfoEntry::set_has_nextindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClusterInfoEntry::clear_has_nextindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClusterInfoEntry::clear_nextindex() {
  nextindex_ = GOOGLE_ULONGLONG(0);
  clear_has_nextindex();
}
inline ::google::protobuf::uint64 ClusterInfoEntry::nextindex() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.nextIndex)
  return nextindex_;
}
inline void ClusterInfoEntry::set_nextindex(::google::protobuf::uint64 value) {
  set_has_nextindex();
  nextindex_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.nextIndex)
}

// optional uint32 role = 4;
inline bool ClusterInfoEntry::has_role() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClusterInfoEntry::set_has_role() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClusterInfoEntry::clear_has_role() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClusterInfoEntry::clear_role() {
  role_ = 0u;
  clear_has_role();
}
inline ::google::protobuf::uint32 ClusterInfoEntry::role() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.role)
  return role_;
}
inline void ClusterInfoEntry::set_role(::google::protobuf::uint32 value) {
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.role)
}

// optional uint64 hasVoted = 5;
inline bool ClusterInfoEntry::has_hasvoted() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClusterInfoEntry::set_has_hasvoted() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClusterInfoEntry::clear_has_hasvoted() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClusterInfoEntry::clear_hasvoted() {
  hasvoted_ = GOOGLE_ULONGLONG(0);
  clear_has_hasvoted();
}
inline ::google::protobuf::uint64 ClusterInfoEntry::hasvoted() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.hasVoted)
  return hasvoted_;
}
inline void ClusterInfoEntry::set_hasvoted(::google::protobuf::uint64 value) {
  set_has_hasvoted();
  hasvoted_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.hasVoted)
}

// optional uint32 forceSync = 6;
inline bool ClusterInfoEntry::has_forcesync() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClusterInfoEntry::set_has_forcesync() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClusterInfoEntry::clear_has_forcesync() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClusterInfoEntry::clear_forcesync() {
  forcesync_ = 0u;
  clear_has_forcesync();
}
inline ::google::protobuf::uint32 ClusterInfoEntry::forcesync() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.forceSync)
  return forcesync_;
}
inline void ClusterInfoEntry::set_forcesync(::google::protobuf::uint32 value) {
  set_has_forcesync();
  forcesync_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.forceSync)
}

// optional uint32 electionWeight = 7;
inline bool ClusterInfoEntry::has_electionweight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClusterInfoEntry::set_has_electionweight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClusterInfoEntry::clear_has_electionweight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClusterInfoEntry::clear_electionweight() {
  electionweight_ = 0u;
  clear_has_electionweight();
}
inline ::google::protobuf::uint32 ClusterInfoEntry::electionweight() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.electionWeight)
  return electionweight_;
}
inline void ClusterInfoEntry::set_electionweight(::google::protobuf::uint32 value) {
  set_has_electionweight();
  electionweight_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.electionWeight)
}

// optional uint64 learnerSource = 8;
inline bool ClusterInfoEntry::has_learnersource() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClusterInfoEntry::set_has_learnersource() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClusterInfoEntry::clear_has_learnersource() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClusterInfoEntry::clear_learnersource() {
  learnersource_ = GOOGLE_ULONGLONG(0);
  clear_has_learnersource();
}
inline ::google::protobuf::uint64 ClusterInfoEntry::learnersource() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.learnerSource)
  return learnersource_;
}
inline void ClusterInfoEntry::set_learnersource(::google::protobuf::uint64 value) {
  set_has_learnersource();
  learnersource_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.learnerSource)
}

// optional uint64 appliedIndex = 9;
inline bool ClusterInfoEntry::has_appliedindex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClusterInfoEntry::set_has_appliedindex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClusterInfoEntry::clear_has_appliedindex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClusterInfoEntry::clear_appliedindex() {
  appliedindex_ = GOOGLE_ULONGLONG(0);
  clear_has_appliedindex();
}
inline ::google::protobuf::uint64 ClusterInfoEntry::appliedindex() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.appliedIndex)
  return appliedindex_;
}
inline void ClusterInfoEntry::set_appliedindex(::google::protobuf::uint64 value) {
  set_has_appliedindex();
  appliedindex_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.appliedIndex)
}

// optional uint32 pipelining = 10;
inline bool ClusterInfoEntry::has_pipelining() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClusterInfoEntry::set_has_pipelining() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClusterInfoEntry::clear_has_pipelining() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClusterInfoEntry::clear_pipelining() {
  pipelining_ = 0u;
  clear_has_pipelining();
}
inline ::google::protobuf::uint32 ClusterInfoEntry::pipelining() const {
  // @@protoc_insertion_point(field_get:alisql.ClusterInfoEntry.pipelining)
  return pipelining_;
}
inline void ClusterInfoEntry::set_pipelining(::google::protobuf::uint32 value) {
  set_has_pipelining();
  pipelining_ = value;
  // @@protoc_insertion_point(field_set:alisql.ClusterInfoEntry.pipelining)
}

// -------------------------------------------------------------------

// PaxosMsg

// optional uint64 configId = 1;
inline bool PaxosMsg::has_configid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaxosMsg::set_has_configid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaxosMsg::clear_has_configid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaxosMsg::clear_configid() {
  configid_ = GOOGLE_ULONGLONG(0);
  clear_has_configid();
}
inline ::google::protobuf::uint64 PaxosMsg::configid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.configId)
  return configid_;
}
inline void PaxosMsg::set_configid(::google::protobuf::uint64 value) {
  set_has_configid();
  configid_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.configId)
}

// required uint64 clusterId = 2;
inline bool PaxosMsg::has_clusterid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaxosMsg::set_has_clusterid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaxosMsg::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaxosMsg::clear_clusterid() {
  clusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_clusterid();
}
inline ::google::protobuf::uint64 PaxosMsg::clusterid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.clusterId)
  return clusterid_;
}
inline void PaxosMsg::set_clusterid(::google::protobuf::uint64 value) {
  set_has_clusterid();
  clusterid_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.clusterId)
}

// required uint64 serverId = 3;
inline bool PaxosMsg::has_serverid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PaxosMsg::set_has_serverid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PaxosMsg::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PaxosMsg::clear_serverid() {
  serverid_ = GOOGLE_ULONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::uint64 PaxosMsg::serverid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.serverId)
  return serverid_;
}
inline void PaxosMsg::set_serverid(::google::protobuf::uint64 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.serverId)
}

// required int32 msgType = 4;
inline bool PaxosMsg::has_msgtype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PaxosMsg::set_has_msgtype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PaxosMsg::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PaxosMsg::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::google::protobuf::int32 PaxosMsg::msgtype() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.msgType)
  return msgtype_;
}
inline void PaxosMsg::set_msgtype(::google::protobuf::int32 value) {
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.msgType)
}

// required uint64 term = 5;
inline bool PaxosMsg::has_term() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PaxosMsg::set_has_term() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PaxosMsg::clear_has_term() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PaxosMsg::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 PaxosMsg::term() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.term)
  return term_;
}
inline void PaxosMsg::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.term)
}

// required uint64 msgId = 6;
inline bool PaxosMsg::has_msgid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PaxosMsg::set_has_msgid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PaxosMsg::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PaxosMsg::clear_msgid() {
  msgid_ = GOOGLE_ULONGLONG(0);
  clear_has_msgid();
}
inline ::google::protobuf::uint64 PaxosMsg::msgid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.msgId)
  return msgid_;
}
inline void PaxosMsg::set_msgid(::google::protobuf::uint64 value) {
  set_has_msgid();
  msgid_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.msgId)
}

// optional uint64 leaderId = 7;
inline bool PaxosMsg::has_leaderid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PaxosMsg::set_has_leaderid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PaxosMsg::clear_has_leaderid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PaxosMsg::clear_leaderid() {
  leaderid_ = GOOGLE_ULONGLONG(0);
  clear_has_leaderid();
}
inline ::google::protobuf::uint64 PaxosMsg::leaderid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.leaderId)
  return leaderid_;
}
inline void PaxosMsg::set_leaderid(::google::protobuf::uint64 value) {
  set_has_leaderid();
  leaderid_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.leaderId)
}

// optional uint64 prevLogIndex = 8;
inline bool PaxosMsg::has_prevlogindex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PaxosMsg::set_has_prevlogindex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PaxosMsg::clear_has_prevlogindex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PaxosMsg::clear_prevlogindex() {
  prevlogindex_ = GOOGLE_ULONGLONG(0);
  clear_has_prevlogindex();
}
inline ::google::protobuf::uint64 PaxosMsg::prevlogindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.prevLogIndex)
  return prevlogindex_;
}
inline void PaxosMsg::set_prevlogindex(::google::protobuf::uint64 value) {
  set_has_prevlogindex();
  prevlogindex_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.prevLogIndex)
}

// optional uint64 prevLogTerm = 9;
inline bool PaxosMsg::has_prevlogterm() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PaxosMsg::set_has_prevlogterm() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PaxosMsg::clear_has_prevlogterm() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PaxosMsg::clear_prevlogterm() {
  prevlogterm_ = GOOGLE_ULONGLONG(0);
  clear_has_prevlogterm();
}
inline ::google::protobuf::uint64 PaxosMsg::prevlogterm() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.prevLogTerm)
  return prevlogterm_;
}
inline void PaxosMsg::set_prevlogterm(::google::protobuf::uint64 value) {
  set_has_prevlogterm();
  prevlogterm_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.prevLogTerm)
}

// repeated .alisql.LogEntry entries = 10;
inline int PaxosMsg::entries_size() const {
  return entries_.size();
}
inline void PaxosMsg::clear_entries() {
  entries_.Clear();
}
inline ::alisql::LogEntry* PaxosMsg::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::alisql::LogEntry >*
PaxosMsg::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:alisql.PaxosMsg.entries)
  return &entries_;
}
inline const ::alisql::LogEntry& PaxosMsg::entries(int index) const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.entries)
  return entries_.Get(index);
}
inline ::alisql::LogEntry* PaxosMsg::add_entries() {
  // @@protoc_insertion_point(field_add:alisql.PaxosMsg.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::alisql::LogEntry >&
PaxosMsg::entries() const {
  // @@protoc_insertion_point(field_list:alisql.PaxosMsg.entries)
  return entries_;
}

// optional uint64 commitIndex = 11;
inline bool PaxosMsg::has_commitindex() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PaxosMsg::set_has_commitindex() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PaxosMsg::clear_has_commitindex() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PaxosMsg::clear_commitindex() {
  commitindex_ = GOOGLE_ULONGLONG(0);
  clear_has_commitindex();
}
inline ::google::protobuf::uint64 PaxosMsg::commitindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.commitIndex)
  return commitindex_;
}
inline void PaxosMsg::set_commitindex(::google::protobuf::uint64 value) {
  set_has_commitindex();
  commitindex_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.commitIndex)
}

// optional bool nocache = 12;
inline bool PaxosMsg::has_nocache() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PaxosMsg::set_has_nocache() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PaxosMsg::clear_has_nocache() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PaxosMsg::clear_nocache() {
  nocache_ = false;
  clear_has_nocache();
}
inline bool PaxosMsg::nocache() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.nocache)
  return nocache_;
}
inline void PaxosMsg::set_nocache(bool value) {
  set_has_nocache();
  nocache_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.nocache)
}

// optional bool isSuccess = 13;
inline bool PaxosMsg::has_issuccess() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PaxosMsg::set_has_issuccess() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PaxosMsg::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PaxosMsg::clear_issuccess() {
  issuccess_ = false;
  clear_has_issuccess();
}
inline bool PaxosMsg::issuccess() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.isSuccess)
  return issuccess_;
}
inline void PaxosMsg::set_issuccess(bool value) {
  set_has_issuccess();
  issuccess_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.isSuccess)
}

// optional uint64 candidateId = 14;
inline bool PaxosMsg::has_candidateid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PaxosMsg::set_has_candidateid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PaxosMsg::clear_has_candidateid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PaxosMsg::clear_candidateid() {
  candidateid_ = GOOGLE_ULONGLONG(0);
  clear_has_candidateid();
}
inline ::google::protobuf::uint64 PaxosMsg::candidateid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.candidateId)
  return candidateid_;
}
inline void PaxosMsg::set_candidateid(::google::protobuf::uint64 value) {
  set_has_candidateid();
  candidateid_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.candidateId)
}

// optional uint64 lastLogIndex = 15;
inline bool PaxosMsg::has_lastlogindex() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PaxosMsg::set_has_lastlogindex() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PaxosMsg::clear_has_lastlogindex() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PaxosMsg::clear_lastlogindex() {
  lastlogindex_ = GOOGLE_ULONGLONG(0);
  clear_has_lastlogindex();
}
inline ::google::protobuf::uint64 PaxosMsg::lastlogindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.lastLogIndex)
  return lastlogindex_;
}
inline void PaxosMsg::set_lastlogindex(::google::protobuf::uint64 value) {
  set_has_lastlogindex();
  lastlogindex_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.lastLogIndex)
}

// optional uint64 lastLogTerm = 16;
inline bool PaxosMsg::has_lastlogterm() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PaxosMsg::set_has_lastlogterm() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PaxosMsg::clear_has_lastlogterm() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PaxosMsg::clear_lastlogterm() {
  lastlogterm_ = GOOGLE_ULONGLONG(0);
  clear_has_lastlogterm();
}
inline ::google::protobuf::uint64 PaxosMsg::lastlogterm() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.lastLogTerm)
  return lastlogterm_;
}
inline void PaxosMsg::set_lastlogterm(::google::protobuf::uint64 value) {
  set_has_lastlogterm();
  lastlogterm_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.lastLogTerm)
}

// optional uint64 force = 17;
inline bool PaxosMsg::has_force() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PaxosMsg::set_has_force() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PaxosMsg::clear_has_force() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PaxosMsg::clear_force() {
  force_ = GOOGLE_ULONGLONG(0);
  clear_has_force();
}
inline ::google::protobuf::uint64 PaxosMsg::force() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.force)
  return force_;
}
inline void PaxosMsg::set_force(::google::protobuf::uint64 value) {
  set_has_force();
  force_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.force)
}

// optional bytes addr = 18;
inline bool PaxosMsg::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaxosMsg::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaxosMsg::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaxosMsg::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
inline const ::std::string& PaxosMsg::addr() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.addr)
  return addr_.GetNoArena();
}
inline void PaxosMsg::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.addr)
}
#if LANG_CXX11
inline void PaxosMsg::set_addr(::std::string&& value) {
  set_has_addr();
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alisql.PaxosMsg.addr)
}
#endif
inline void PaxosMsg::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alisql.PaxosMsg.addr)
}
inline void PaxosMsg::set_addr(const void* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alisql.PaxosMsg.addr)
}
inline ::std::string* PaxosMsg::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaxosMsg::release_addr() {
  // @@protoc_insertion_point(field_release:alisql.PaxosMsg.addr)
  if (!has_addr()) {
    return NULL;
  }
  clear_has_addr();
  return addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaxosMsg::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:alisql.PaxosMsg.addr)
}

// optional bool voteGranted = 19;
inline bool PaxosMsg::has_votegranted() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PaxosMsg::set_has_votegranted() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PaxosMsg::clear_has_votegranted() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PaxosMsg::clear_votegranted() {
  votegranted_ = false;
  clear_has_votegranted();
}
inline bool PaxosMsg::votegranted() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.voteGranted)
  return votegranted_;
}
inline void PaxosMsg::set_votegranted(bool value) {
  set_has_votegranted();
  votegranted_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.voteGranted)
}

// optional bool ignoreCheck = 20;
inline bool PaxosMsg::has_ignorecheck() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PaxosMsg::set_has_ignorecheck() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PaxosMsg::clear_has_ignorecheck() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PaxosMsg::clear_ignorecheck() {
  ignorecheck_ = false;
  clear_has_ignorecheck();
}
inline bool PaxosMsg::ignorecheck() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.ignoreCheck)
  return ignorecheck_;
}
inline void PaxosMsg::set_ignorecheck(bool value) {
  set_has_ignorecheck();
  ignorecheck_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.ignoreCheck)
}

// optional uint64 lcType = 21;
inline bool PaxosMsg::has_lctype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PaxosMsg::set_has_lctype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PaxosMsg::clear_has_lctype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PaxosMsg::clear_lctype() {
  lctype_ = GOOGLE_ULONGLONG(0);
  clear_has_lctype();
}
inline ::google::protobuf::uint64 PaxosMsg::lctype() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.lcType)
  return lctype_;
}
inline void PaxosMsg::set_lctype(::google::protobuf::uint64 value) {
  set_has_lctype();
  lctype_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.lcType)
}

// optional uint64 minMatchIndex = 22;
inline bool PaxosMsg::has_minmatchindex() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PaxosMsg::set_has_minmatchindex() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PaxosMsg::clear_has_minmatchindex() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PaxosMsg::clear_minmatchindex() {
  minmatchindex_ = GOOGLE_ULONGLONG(0);
  clear_has_minmatchindex();
}
inline ::google::protobuf::uint64 PaxosMsg::minmatchindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.minMatchIndex)
  return minmatchindex_;
}
inline void PaxosMsg::set_minmatchindex(::google::protobuf::uint64 value) {
  set_has_minmatchindex();
  minmatchindex_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.minMatchIndex)
}

// optional uint64 appliedIndex = 23;
inline bool PaxosMsg::has_appliedindex() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PaxosMsg::set_has_appliedindex() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PaxosMsg::clear_has_appliedindex() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PaxosMsg::clear_appliedindex() {
  appliedindex_ = GOOGLE_ULONGLONG(0);
  clear_has_appliedindex();
}
inline ::google::protobuf::uint64 PaxosMsg::appliedindex() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.appliedIndex)
  return appliedindex_;
}
inline void PaxosMsg::set_appliedindex(::google::protobuf::uint64 value) {
  set_has_appliedindex();
  appliedindex_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.appliedIndex)
}

// optional uint64 newClusterId = 24;
inline bool PaxosMsg::has_newclusterid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PaxosMsg::set_has_newclusterid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PaxosMsg::clear_has_newclusterid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PaxosMsg::clear_newclusterid() {
  newclusterid_ = GOOGLE_ULONGLONG(0);
  clear_has_newclusterid();
}
inline ::google::protobuf::uint64 PaxosMsg::newclusterid() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.newClusterId)
  return newclusterid_;
}
inline void PaxosMsg::set_newclusterid(::google::protobuf::uint64 value) {
  set_has_newclusterid();
  newclusterid_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.newClusterId)
}

// repeated .alisql.ClusterInfoEntry ciEntries = 25;
inline int PaxosMsg::cientries_size() const {
  return cientries_.size();
}
inline void PaxosMsg::clear_cientries() {
  cientries_.Clear();
}
inline ::alisql::ClusterInfoEntry* PaxosMsg::mutable_cientries(int index) {
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.ciEntries)
  return cientries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::alisql::ClusterInfoEntry >*
PaxosMsg::mutable_cientries() {
  // @@protoc_insertion_point(field_mutable_list:alisql.PaxosMsg.ciEntries)
  return &cientries_;
}
inline const ::alisql::ClusterInfoEntry& PaxosMsg::cientries(int index) const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.ciEntries)
  return cientries_.Get(index);
}
inline ::alisql::ClusterInfoEntry* PaxosMsg::add_cientries() {
  // @@protoc_insertion_point(field_add:alisql.PaxosMsg.ciEntries)
  return cientries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::alisql::ClusterInfoEntry >&
PaxosMsg::cientries() const {
  // @@protoc_insertion_point(field_list:alisql.PaxosMsg.ciEntries)
  return cientries_;
}

// optional uint32 role = 26;
inline bool PaxosMsg::has_role() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PaxosMsg::set_has_role() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PaxosMsg::clear_has_role() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PaxosMsg::clear_role() {
  role_ = 0u;
  clear_has_role();
}
inline ::google::protobuf::uint32 PaxosMsg::role() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.role)
  return role_;
}
inline void PaxosMsg::set_role(::google::protobuf::uint32 value) {
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.role)
}

// optional .alisql.CompressedLogEntries compressedEntries = 27;
inline bool PaxosMsg::has_compressedentries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaxosMsg::set_has_compressedentries() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaxosMsg::clear_has_compressedentries() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaxosMsg::clear_compressedentries() {
  if (compressedentries_ != NULL) compressedentries_->Clear();
  clear_has_compressedentries();
}
inline const ::alisql::CompressedLogEntries& PaxosMsg::_internal_compressedentries() const {
  return *compressedentries_;
}
inline const ::alisql::CompressedLogEntries& PaxosMsg::compressedentries() const {
  const ::alisql::CompressedLogEntries* p = compressedentries_;
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.compressedEntries)
  return p != NULL ? *p : *reinterpret_cast<const ::alisql::CompressedLogEntries*>(
      &::alisql::_CompressedLogEntries_default_instance_);
}
inline ::alisql::CompressedLogEntries* PaxosMsg::release_compressedentries() {
  // @@protoc_insertion_point(field_release:alisql.PaxosMsg.compressedEntries)
  clear_has_compressedentries();
  ::alisql::CompressedLogEntries* temp = compressedentries_;
  compressedentries_ = NULL;
  return temp;
}
inline ::alisql::CompressedLogEntries* PaxosMsg::mutable_compressedentries() {
  set_has_compressedentries();
  if (compressedentries_ == NULL) {
    auto* p = CreateMaybeMessage<::alisql::CompressedLogEntries>(GetArenaNoVirtual());
    compressedentries_ = p;
  }
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.compressedEntries)
  return compressedentries_;
}
inline void PaxosMsg::set_allocated_compressedentries(::alisql::CompressedLogEntries* compressedentries) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete compressedentries_;
  }
  if (compressedentries) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      compressedentries = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, compressedentries, submessage_arena);
    }
    set_has_compressedentries();
  } else {
    clear_has_compressedentries();
  }
  compressedentries_ = compressedentries;
  // @@protoc_insertion_point(field_set_allocated:alisql.PaxosMsg.compressedEntries)
}

// optional bytes extra = 28;
inline bool PaxosMsg::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaxosMsg::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaxosMsg::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaxosMsg::clear_extra() {
  extra_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extra();
}
inline const ::std::string& PaxosMsg::extra() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.extra)
  return extra_.GetNoArena();
}
inline void PaxosMsg::set_extra(const ::std::string& value) {
  set_has_extra();
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.extra)
}
#if LANG_CXX11
inline void PaxosMsg::set_extra(::std::string&& value) {
  set_has_extra();
  extra_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alisql.PaxosMsg.extra)
}
#endif
inline void PaxosMsg::set_extra(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extra();
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alisql.PaxosMsg.extra)
}
inline void PaxosMsg::set_extra(const void* value, size_t size) {
  set_has_extra();
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alisql.PaxosMsg.extra)
}
inline ::std::string* PaxosMsg::mutable_extra() {
  set_has_extra();
  // @@protoc_insertion_point(field_mutable:alisql.PaxosMsg.extra)
  return extra_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PaxosMsg::release_extra() {
  // @@protoc_insertion_point(field_release:alisql.PaxosMsg.extra)
  if (!has_extra()) {
    return NULL;
  }
  clear_has_extra();
  return extra_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PaxosMsg::set_allocated_extra(::std::string* extra) {
  if (extra != NULL) {
    set_has_extra();
  } else {
    clear_has_extra();
  }
  extra_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra);
  // @@protoc_insertion_point(field_set_allocated:alisql.PaxosMsg.extra)
}

// optional .alisql.PaxosMsg.MsgErrorType msgError = 30;
inline bool PaxosMsg::has_msgerror() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PaxosMsg::set_has_msgerror() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PaxosMsg::clear_has_msgerror() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PaxosMsg::clear_msgerror() {
  msgerror_ = 0;
  clear_has_msgerror();
}
inline ::alisql::PaxosMsg_MsgErrorType PaxosMsg::msgerror() const {
  // @@protoc_insertion_point(field_get:alisql.PaxosMsg.msgError)
  return static_cast< ::alisql::PaxosMsg_MsgErrorType >(msgerror_);
}
inline void PaxosMsg::set_msgerror(::alisql::PaxosMsg_MsgErrorType value) {
  assert(::alisql::PaxosMsg_MsgErrorType_IsValid(value));
  set_has_msgerror();
  msgerror_ = value;
  // @@protoc_insertion_point(field_set:alisql.PaxosMsg.msgError)
}

// -------------------------------------------------------------------

// TestMsg1

// required uint64 id = 1;
inline bool TestMsg1::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestMsg1::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestMsg1::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestMsg1::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestMsg1::id() const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg1.id)
  return id_;
}
inline void TestMsg1::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:alisql.TestMsg1.id)
}

// optional uint64 c1 = 2;
inline bool TestMsg1::has_c1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestMsg1::set_has_c1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestMsg1::clear_has_c1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestMsg1::clear_c1() {
  c1_ = GOOGLE_ULONGLONG(0);
  clear_has_c1();
}
inline ::google::protobuf::uint64 TestMsg1::c1() const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg1.c1)
  return c1_;
}
inline void TestMsg1::set_c1(::google::protobuf::uint64 value) {
  set_has_c1();
  c1_ = value;
  // @@protoc_insertion_point(field_set:alisql.TestMsg1.c1)
}

// -------------------------------------------------------------------

// TestMsg2

// required uint64 id = 1;
inline bool TestMsg2::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestMsg2::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestMsg2::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestMsg2::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestMsg2::id() const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg2.id)
  return id_;
}
inline void TestMsg2::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:alisql.TestMsg2.id)
}

// optional uint64 c1 = 2;
inline bool TestMsg2::has_c1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestMsg2::set_has_c1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestMsg2::clear_has_c1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestMsg2::clear_c1() {
  c1_ = GOOGLE_ULONGLONG(0);
  clear_has_c1();
}
inline ::google::protobuf::uint64 TestMsg2::c1() const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg2.c1)
  return c1_;
}
inline void TestMsg2::set_c1(::google::protobuf::uint64 value) {
  set_has_c1();
  c1_ = value;
  // @@protoc_insertion_point(field_set:alisql.TestMsg2.c1)
}

// repeated uint64 c2 = 3;
inline int TestMsg2::c2_size() const {
  return c2_.size();
}
inline void TestMsg2::clear_c2() {
  c2_.Clear();
}
inline ::google::protobuf::uint64 TestMsg2::c2(int index) const {
  // @@protoc_insertion_point(field_get:alisql.TestMsg2.c2)
  return c2_.Get(index);
}
inline void TestMsg2::set_c2(int index, ::google::protobuf::uint64 value) {
  c2_.Set(index, value);
  // @@protoc_insertion_point(field_set:alisql.TestMsg2.c2)
}
inline void TestMsg2::add_c2(::google::protobuf::uint64 value) {
  c2_.Add(value);
  // @@protoc_insertion_point(field_add:alisql.TestMsg2.c2)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
TestMsg2::c2() const {
  // @@protoc_insertion_point(field_list:alisql.TestMsg2.c2)
  return c2_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
TestMsg2::mutable_c2() {
  // @@protoc_insertion_point(field_mutable_list:alisql.TestMsg2.c2)
  return &c2_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace alisql

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::alisql::PaxosMsg_MsgErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::alisql::PaxosMsg_MsgErrorType>() {
  return ::alisql::PaxosMsg_MsgErrorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_paxos_2eproto
